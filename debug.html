<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeltaProphecy</title>
  <style>
    @font-face {
      font-family: 'ProphecyType';
      src: url('./assets/PROPHECYTYPE.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'DTMSans';
      src: url('./assets/DTM-Sans.otf') format('opentype');
      font-display: swap;
    }
    
    html, body {
      margin: 0; padding: 0;
      font-family: 'DTMSans', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: white;
      background: black;
    }

    #textContainer {
      width: 75vw;
      max-width: 350px;
      margin-top: 20px;
      margin-bottom: 10px;
      text-align: center;
      font-family: 'ProphecyType', serif;
      font-size: 32px;
      line-height: 1;
      color: transparent;
      background-size: 256px 256px;
      -webkit-background-clip: text;
      background-clip: text;
      mix-blend-mode: screen;
      animation: scrollBg 30s linear infinite;
      background-repeat: repeat;
    }

    @keyframes scrollBg {
      0% { background-position: 0 0; }
      100% { background-position: 512px 512px; }
    }

#output {
  position: relative;
  width: 90vw;
  max-width: 512px;
  aspect-ratio: 2 / 1;
  max-height: 256px;
}

    canvas {
      position: absolute;
      width: 512px;   /* fix to pixel size */
      height: 256px;  /* fix to pixel size */
      top: 0; left: 0;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      background: transparent;
    }
    
    #ghostIcon {
      z-index: 1;
      opacity: 0.4;
      pointer-events: none;
      top: -50px;
    }

    #panel {
      z-index: 2;
      top: -50px;
    }

    input[type="file"], input[type="text"] {
      margin-top: 10px;
      padding: 5px;
      width: 75vw;
      max-width: 512px;
    }

    .checkbox-container {
      margin-top: 10px;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    h1 {
      margin-top: 15px;
      margin-bottom: 5px;
      text-align: center;
    }
    
    footer {
      margin-top: 20px;
      padding: 10px;
      color: #fff;
      font-size: 14px;
      text-align: center;
      width: 100%;
      max-width: 512px;
    }
    
    .alt-font {
      font-family: 'ProphecyType', serif;
    }
    
    /* Remove default appearance */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 125px;
      max-width: 512px;
      height: 12px;
      background: transparent; /* Make input background transparent */
      margin-top: 10px;
      padding: 0;
      border-radius: 0px;
      cursor: pointer;
    }
    
    /* WebKit browsers (Chrome, Safari, Edge) */
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.2); /* translucent white */
      border-radius: 0px;
    }
    
    /* Firefox */
    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 0px;
    }
    
    /* Optional: style the slider thumb */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 15px;
      height: 15px;
      background: white;
      border: 0px;
      margin-top: -4px; /* Center thumb vertically */
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 15px;
      height: 15px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    
    #directions {
      max-width: 512px;
      text-align: center;
      color: #fff;
      margin-top: 10px;
      font-size: 14px;
      line-height: 1.4;
    }

    input[type="text"] {
      font-family: 'DTMSans', sans-serif;
      background-color: black;
      color: white;
      border: 2px solid white;
      padding: 5px 10px;
      outline: none;
      border-radius: 0px; /* optional, for rounded corners */
      box-sizing: border-box;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #fff; /* keep white outline on focus */
      box-shadow: 0 0 5px white; /* optional glow on focus */
    }

    .custom-file-upload {
      display: inline-block;
      font-family: 'DTMSans', sans-serif;
      background-color: black;
      color: white;
      border: 2px solid white;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 0px;
      user-select: none;
      text-align: center;
    }
    
    .custom-file-upload:hover {
      background-color: #222;
      border-color: #fff;
    }
    
    .custom-file-upload:active {
      background-color: #111;
    }
    
  </style>
</head>
<body>
  <h1>Deltarune Prophecy Panel Generator</h1>
  <input type="file" id="imgInput" accept="image/*" style="display:none;" />
  <label for="imgInput" class="custom-file-upload">Upload Image</label>
  <input type="text" id="textInput" placeholder="Enter prophecy text" />
  <div class="checkbox-container">
    <label for="imgScale">Image Scale:</label>
    <input type="range" id="imgScale" min="0.1" max="3" value="1" step="0.01" />
    <span id="imgScaleValue">1.00×</span>
  </div>
  <div class="checkbox-container">
    <label for="imgYOffset">Image Y Offset:</label>
    <input type="range" id="imgYOffset" min="-55" max="55" value="0" />
    <span id="imgYOffsetValue">0px</span>
  </div>
  <div id="textContainer">Your prophecy here</div>
  <div id="output">
    <canvas id="ghostIcon" width="512" height="256"></canvas>
    <canvas id="panel" width="512" height="256"></canvas>
  </div>

  <div id="directions">
  <p>Upload a white-only or black-and-white image above to begin. Type your prophecy text in the box. You can use /n to move to a new line.</p>
  </div>
  <footer>
    <p>© HippoWaterMelon 2025 - DELTARUNE © 2025 Toby Fox - <span class="alt-font">ProphecyType</span> by u/RelevantAd2788 - Determination Sans by Haley Wakamatsu</p>
  </footer>

  <script>
    const imgInput = document.getElementById('imgInput');
    const textInput = document.getElementById('textInput');
    const panel = document.getElementById('panel');
    const ghostIcon = document.getElementById('ghostIcon');
    const ctx = panel.getContext('2d');
    const gtx = ghostIcon.getContext('2d');
    const textContainer = document.getElementById('textContainer');
    const imgYOffset = document.getElementById('imgYOffset');
    const imgScale = document.getElementById('imgScale');
    const imgScaleValue = document.getElementById('imgScaleValue');


    let maskImage = null;
    let resultCanvas = null;
    let scrollOffset = 0;
    let ghostStarted = false;
    let placeholder = null;

    function loadImageFromFile(imagePath) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          const tileSize = 256;
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = tileSize;
          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = false;
          // Draw the 256x256 image directly
          ctx.drawImage(img, 0, 0, tileSize, tileSize);
          resolve(canvas);
        };
        img.onerror = (e) => {
          console.error('Failed to load image from ./assets/depth.png:', e);
          // Create a fallback pattern
          const canvas = document.createElement('canvas');
          canvas.width = canvas.height = 256;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(0, 0, 128, 128);
          ctx.fillStyle = '#00ff00';
          ctx.fillRect(128, 0, 128, 128);
          ctx.fillStyle = '#0000ff';
          ctx.fillRect(0, 128, 128, 128);
          ctx.fillStyle = '#ffff00';
          ctx.fillRect(128, 128, 128, 128);
          resolve(canvas);
        };
        img.src = imagePath;
      });
    }

    function drawPanel() {
      if (!maskImage || !placeholder) return;

      scrollOffset = (scrollOffset + 1) % placeholder.width;
      ctx.clearRect(0, 0, 512, 512);
      ctx.imageSmoothingEnabled = false;

      // Determine canvas size based on setting
      const useOriginalRes = false;
      const canvasSize = useOriginalRes ? Math.max(maskImage.width, maskImage.height, 256) : 256;
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = tempCanvas.height = canvasSize;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.imageSmoothingEnabled = false;

      const offset = scrollOffset % placeholder.width;

      // Tile the placeholder texture over the canvas area with scroll offset
      for (let y = -offset; y < canvasSize + placeholder.height; y += placeholder.height) {
        for (let x = -offset; x < canvasSize + placeholder.width; x += placeholder.width) {
          tempCtx.drawImage(placeholder, x, y);
        }
      }

      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = maskCanvas.height = canvasSize;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.clearRect(0, 0, canvasSize, canvasSize);
      maskCtx.imageSmoothingEnabled = false;

      let dx, dy, dw, dh;
      
      if (useOriginalRes) {
        // Keep original resolution - center the image
        dw = maskImage.width;
        dh = maskImage.height;
        dx = (canvasSize - dw) / 2;
        dy = (canvasSize - dh) / 2;
      } else {
        // Scale to fit within canvas
        const scale = Math.min(canvasSize / maskImage.width, canvasSize / maskImage.height);
        dw = maskImage.width * scale;
        dh = maskImage.height * scale;
        dx = (canvasSize - dw) / 2;
        dy = (canvasSize - dh) / 2;
      }

      maskCtx.drawImage(maskImage, dx, dy, dw, dh);

      const maskData = maskCtx.getImageData(0, 0, canvasSize, canvasSize);
      const texData = tempCtx.getImageData(0, 0, canvasSize, canvasSize);
      const result = tempCtx.createImageData(canvasSize, canvasSize);

      for (let i = 0; i < maskData.data.length; i += 4) {
        const r = maskData.data[i];
        const g = maskData.data[i + 1];
        const b = maskData.data[i + 2];
        const a = maskData.data[i + 3];
        const brightness = (r + g + b) / 3;

        if (brightness > 200 && a > 0) {
          result.data[i] = texData.data[i];
          result.data[i + 1] = texData.data[i + 1];
          result.data[i + 2] = texData.data[i + 2];
          result.data[i + 3] = 255;
        } else {
          result.data[i + 3] = 0;
        }
      }

      resultCanvas = document.createElement('canvas');
      resultCanvas.width = resultCanvas.height = canvasSize;
      resultCanvas.getContext('2d').putImageData(result, 0, 0);

      // Center the result on the 512x512 display canvas
      const displayX = (512 - canvasSize) / 2;
      const displayY = -parseInt(imgYOffset.value, 10); // (512 - canvasSize) / 2;
      let scale = parseFloat(imgScale.value);

      // Scale after masking
      const scaledW = resultCanvas.width * scale;
      const scaledH = resultCanvas.height * scale;
      const scaledX = (512 - scaledW) / 2;
      const scaledY = -parseInt(imgYOffset.value, 10);
      
      ctx.drawImage(resultCanvas, 0, 0, resultCanvas.width, resultCanvas.height, scaledX, scaledY, scaledW, scaledH);

    }

    function drawGhostIcon() {
      if (!resultCanvas) return;

      const t = performance.now() / 1000;
      const offset = Math.sin(t * 2) * 6;

      gtx.clearRect(0, 0, 512, 512);
      gtx.imageSmoothingEnabled = false;
      gtx.setTransform(1, 0, 0, 1, offset, offset);
      
      // Center the ghost icon same as the main panel
      const displayX = (512 - resultCanvas.width) / 2;
      const displayY = -parseInt(imgYOffset.value, 10); // (512 - resultCanvas.height) / 2;
      let scale = parseFloat(imgScale.value);

      const scaledW = resultCanvas.width * scale;
      const scaledH = resultCanvas.height * scale;
      const scaledX = (512 - scaledW) / 2;
      const scaledY = -parseInt(imgYOffset.value, 10);
      
      gtx.drawImage(resultCanvas, 0, 0, resultCanvas.width, resultCanvas.height, scaledX, scaledY, scaledW, scaledH);

      gtx.setTransform(1, 0, 0, 1, 0, 0);

      requestAnimationFrame(drawGhostIcon);
    }

    function tryStartGhost() {
      if (!ghostStarted && resultCanvas) {
        ghostStarted = true;
        requestAnimationFrame(drawGhostIcon);
      }
    }

    imgInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        maskImage = img;
        drawPanel();
        tryStartGhost();
      };
      img.src = URL.createObjectURL(file);
    });

    textInput.addEventListener('input', () => {
      const formattedText = (textInput.value || 'Your prophecy here').replace(/\/n/g, '<br>');
      textContainer.innerHTML = formattedText;
    });

    // Setup placeholder tile and start draw loop
    Promise.all([
      loadImageFromFile('./assets/depth-2.png'), // For the masked panel
      loadImageFromFile('./assets/depth-text.png') // For the text
    ]).then(([tile, textBG]) => {
      placeholder = tile;
      textContainer.style.backgroundImage = `url(${textBG.toDataURL()})`;
      setInterval(drawPanel, 1000 / 30);
    });
    
    imgYOffset.addEventListener('input', () => {
      imgYOffsetValue.textContent = imgYOffset.value + 'px';
      if (maskImage) drawPanel();
    });

    imgScale.addEventListener('input', () => {
      imgScaleValue.textContent = parseFloat(imgScale.value).toFixed(2) + '×';
      if (maskImage) drawPanel();
    });

    window.addEventListener('load', () => {
      const defaultImg = new Image();
      defaultImg.onload = () => {
        maskImage = defaultImg;
        drawPanel();
        tryStartGhost();
      };
      defaultImg.src = './assets/heroes.png';

      textInput.value = "But lo, on hopes and dreams they send. /n Three heroes at the world's end.";
      // Trigger input event so display updates immediately
      textInput.dispatchEvent(new Event('input'));
    });    
  </script>
</body>
</html>
